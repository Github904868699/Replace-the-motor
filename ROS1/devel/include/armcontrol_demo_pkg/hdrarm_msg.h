// Generated by gencpp from file armcontrol_demo_pkg/hdrarm_msg.msg
// DO NOT EDIT!


#ifndef ARMCONTROL_DEMO_PKG_MESSAGE_HDRARM_MSG_H
#define ARMCONTROL_DEMO_PKG_MESSAGE_HDRARM_MSG_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace armcontrol_demo_pkg
{
template <class ContainerAllocator>
struct hdrarm_msg_
{
  typedef hdrarm_msg_<ContainerAllocator> Type;

  hdrarm_msg_()
    : motor_state()
    , arm_mode()
    , Emergency_Stop(false)
    , drag_teachin()
    , drag_teachin_name()
    , joint1_angle(0.0)
    , joint2_angle(0.0)
    , joint3_angle(0.0)
    , joint4_angle(0.0)
    , joint5_angle(0.0)
    , joint6_angle(0.0)
    , arm_position_x(0.0)
    , arm_position_y(0.0)
    , arm_position_z(0.0)
    , arm_orientation_x(0.0)
    , arm_orientation_y(0.0)
    , arm_orientation_z(0.0)
    , arm_orientation_w(0.0)  {
    }
  hdrarm_msg_(const ContainerAllocator& _alloc)
    : motor_state(_alloc)
    , arm_mode(_alloc)
    , Emergency_Stop(false)
    , drag_teachin(_alloc)
    , drag_teachin_name(_alloc)
    , joint1_angle(0.0)
    , joint2_angle(0.0)
    , joint3_angle(0.0)
    , joint4_angle(0.0)
    , joint5_angle(0.0)
    , joint6_angle(0.0)
    , arm_position_x(0.0)
    , arm_position_y(0.0)
    , arm_position_z(0.0)
    , arm_orientation_x(0.0)
    , arm_orientation_y(0.0)
    , arm_orientation_z(0.0)
    , arm_orientation_w(0.0)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _motor_state_type;
  _motor_state_type motor_state;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _arm_mode_type;
  _arm_mode_type arm_mode;

   typedef uint8_t _Emergency_Stop_type;
  _Emergency_Stop_type Emergency_Stop;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _drag_teachin_type;
  _drag_teachin_type drag_teachin;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _drag_teachin_name_type;
  _drag_teachin_name_type drag_teachin_name;

   typedef double _joint1_angle_type;
  _joint1_angle_type joint1_angle;

   typedef double _joint2_angle_type;
  _joint2_angle_type joint2_angle;

   typedef double _joint3_angle_type;
  _joint3_angle_type joint3_angle;

   typedef double _joint4_angle_type;
  _joint4_angle_type joint4_angle;

   typedef double _joint5_angle_type;
  _joint5_angle_type joint5_angle;

   typedef double _joint6_angle_type;
  _joint6_angle_type joint6_angle;

   typedef double _arm_position_x_type;
  _arm_position_x_type arm_position_x;

   typedef double _arm_position_y_type;
  _arm_position_y_type arm_position_y;

   typedef double _arm_position_z_type;
  _arm_position_z_type arm_position_z;

   typedef double _arm_orientation_x_type;
  _arm_orientation_x_type arm_orientation_x;

   typedef double _arm_orientation_y_type;
  _arm_orientation_y_type arm_orientation_y;

   typedef double _arm_orientation_z_type;
  _arm_orientation_z_type arm_orientation_z;

   typedef double _arm_orientation_w_type;
  _arm_orientation_w_type arm_orientation_w;





  typedef boost::shared_ptr< ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> const> ConstPtr;

}; // struct hdrarm_msg_

typedef ::armcontrol_demo_pkg::hdrarm_msg_<std::allocator<void> > hdrarm_msg;

typedef boost::shared_ptr< ::armcontrol_demo_pkg::hdrarm_msg > hdrarm_msgPtr;
typedef boost::shared_ptr< ::armcontrol_demo_pkg::hdrarm_msg const> hdrarm_msgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator1> & lhs, const ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator2> & rhs)
{
  return lhs.motor_state == rhs.motor_state &&
    lhs.arm_mode == rhs.arm_mode &&
    lhs.Emergency_Stop == rhs.Emergency_Stop &&
    lhs.drag_teachin == rhs.drag_teachin &&
    lhs.drag_teachin_name == rhs.drag_teachin_name &&
    lhs.joint1_angle == rhs.joint1_angle &&
    lhs.joint2_angle == rhs.joint2_angle &&
    lhs.joint3_angle == rhs.joint3_angle &&
    lhs.joint4_angle == rhs.joint4_angle &&
    lhs.joint5_angle == rhs.joint5_angle &&
    lhs.joint6_angle == rhs.joint6_angle &&
    lhs.arm_position_x == rhs.arm_position_x &&
    lhs.arm_position_y == rhs.arm_position_y &&
    lhs.arm_position_z == rhs.arm_position_z &&
    lhs.arm_orientation_x == rhs.arm_orientation_x &&
    lhs.arm_orientation_y == rhs.arm_orientation_y &&
    lhs.arm_orientation_z == rhs.arm_orientation_z &&
    lhs.arm_orientation_w == rhs.arm_orientation_w;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator1> & lhs, const ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace armcontrol_demo_pkg

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "5a62e58a22a17162b499a805b6b83bb9";
  }

  static const char* value(const ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x5a62e58a22a17162ULL;
  static const uint64_t static_value2 = 0xb499a805b6b83bb9ULL;
};

template<class ContainerAllocator>
struct DataType< ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "armcontrol_demo_pkg/hdrarm_msg";
  }

  static const char* value(const ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string motor_state      #电机状态   ps:enable/disable\n"
"string arm_mode		    #机械臂模式	ps:arm_sleep/arm_control_demo/arm_control_moveit_fk/arm_control_moveit_ik\n"
"bool Emergency_Stop     #急停\n"
"string drag_teachin     #拖动示教   ps:false/write/read\n"
"string drag_teachin_name#拖动示教存储文件名\n"
"float64 joint1_angle    #moveit正解使用\n"
"float64 joint2_angle    #moveit正解使用\n"
"float64 joint3_angle    #moveit正解使用\n"
"float64 joint4_angle    #moveit正解使用\n"
"float64 joint5_angle    #moveit正解使用\n"
"float64 joint6_angle    #moveit正解使用\n"
"float64 arm_position_x		#moveit逆解使用\n"
"float64 arm_position_y		#moveit逆解使用\n"
"float64 arm_position_z		#moveit逆解使用\n"
"float64 arm_orientation_x	#moveit逆解使用\n"
"float64 arm_orientation_y	#moveit逆解使用\n"
"float64 arm_orientation_z	#moveit逆解使用\n"
"float64 arm_orientation_w	#moveit逆解使用\n"
;
  }

  static const char* value(const ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.motor_state);
      stream.next(m.arm_mode);
      stream.next(m.Emergency_Stop);
      stream.next(m.drag_teachin);
      stream.next(m.drag_teachin_name);
      stream.next(m.joint1_angle);
      stream.next(m.joint2_angle);
      stream.next(m.joint3_angle);
      stream.next(m.joint4_angle);
      stream.next(m.joint5_angle);
      stream.next(m.joint6_angle);
      stream.next(m.arm_position_x);
      stream.next(m.arm_position_y);
      stream.next(m.arm_position_z);
      stream.next(m.arm_orientation_x);
      stream.next(m.arm_orientation_y);
      stream.next(m.arm_orientation_z);
      stream.next(m.arm_orientation_w);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct hdrarm_msg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::armcontrol_demo_pkg::hdrarm_msg_<ContainerAllocator>& v)
  {
    if (false || !indent.empty())
      s << std::endl;
    s << indent << "motor_state: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.motor_state);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "arm_mode: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.arm_mode);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "Emergency_Stop: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Emergency_Stop);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "drag_teachin: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.drag_teachin);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "drag_teachin_name: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.drag_teachin_name);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "joint1_angle: ";
    Printer<double>::stream(s, indent + "  ", v.joint1_angle);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "joint2_angle: ";
    Printer<double>::stream(s, indent + "  ", v.joint2_angle);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "joint3_angle: ";
    Printer<double>::stream(s, indent + "  ", v.joint3_angle);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "joint4_angle: ";
    Printer<double>::stream(s, indent + "  ", v.joint4_angle);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "joint5_angle: ";
    Printer<double>::stream(s, indent + "  ", v.joint5_angle);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "joint6_angle: ";
    Printer<double>::stream(s, indent + "  ", v.joint6_angle);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "arm_position_x: ";
    Printer<double>::stream(s, indent + "  ", v.arm_position_x);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "arm_position_y: ";
    Printer<double>::stream(s, indent + "  ", v.arm_position_y);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "arm_position_z: ";
    Printer<double>::stream(s, indent + "  ", v.arm_position_z);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "arm_orientation_x: ";
    Printer<double>::stream(s, indent + "  ", v.arm_orientation_x);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "arm_orientation_y: ";
    Printer<double>::stream(s, indent + "  ", v.arm_orientation_y);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "arm_orientation_z: ";
    Printer<double>::stream(s, indent + "  ", v.arm_orientation_z);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "arm_orientation_w: ";
    Printer<double>::stream(s, indent + "  ", v.arm_orientation_w);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ARMCONTROL_DEMO_PKG_MESSAGE_HDRARM_MSG_H
